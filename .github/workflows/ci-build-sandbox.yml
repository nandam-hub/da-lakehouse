name: CI-Build Sandbox

on:
  workflow_call:
    inputs:
      environment:
        description: "Target environment"
        required: false
        type: string
        default: "sandbox"
      bundle_name:
        description: "Specific bundle to deploy (optional)"
        required: false
        type: string
        default: ""
  push:
    branches:
      - "**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: false
        type: choice
        options:
          - sandbox
        default: "sandbox"

permissions:
  id-token: write
  contents: read
  security-events: write

jobs:
  build:
    uses: ./.github/workflows/build-template.yml
    with:
      environment: ${{ inputs.environment || 'sandbox' }}
      image_tag: "latest"
    secrets: inherit
    permissions:
      contents: read
      id-token: write

  deploy:
    needs: build
    runs-on: self-hosted # Windows self-hosted runner
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Install AWS CLI v2 (if missing) on Windows
      - name: Install AWS CLI v2 (Windows)
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          if (-not (Get-Command aws -ErrorAction SilentlyContinue)) {
            Write-Host "Installing AWS CLI v2..."
            $pkg = "$env:USERPROFILE\Downloads\AWSCLIV2.msi"
            Invoke-WebRequest -Uri "https://awscli.amazonaws.com/AWSCLIV2.msi" -OutFile $pkg
            Start-Process msiexec.exe -Wait -ArgumentList "/i `"$pkg`" /qn"
          } else {
            Write-Host "AWS CLI already installed: $(aws --version)"
          }
          aws --version

      # Load AWS Region from .github/parameters.yml using PowerShell-Yaml
      - name: Load AWS Region
        id: load-region
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          # Install PowerShell-Yaml if missing
          if (-not (Get-Module -ListAvailable -Name powershell-yaml)) {
            Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -Scope CurrentUser
            Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted
            Install-Module -Name powershell-yaml -Force -Scope CurrentUser
          }

          $yamlPath = ".github/parameters.yml"
          if (-not (Test-Path $yamlPath)) {
            Write-Host "❌ parameters.yml not found at $yamlPath"
            $AWS_REGION = "us-east-1"  # Default region
          } else {
            $yaml = Get-Content $yamlPath -Raw
            $obj = ConvertFrom-Yaml -Yaml $yaml
            $AWS_REGION = $obj.parameters.environment_variables.AWS_REGION
          }

          "AWS_REGION=$AWS_REGION" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "aws-region=$AWS_REGION" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE }}
          aws-region: ${{ steps.load-region.outputs.aws-region }}
          audience: sts.amazonaws.com

      - name: Get Databricks credentials from AWS Secrets Manager
        id: get-secrets
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          $secretName = "assetbundle-sandbox-credenttials"
          Write-Host "Fetching secret from AWS Secrets Manager: $secretName"
          try {
            $SECRET_SP = aws secretsmanager get-secret-value `
              --secret-id $secretName `
              --query 'SecretString' `
              --output text `
              --region "${{ steps.load-region.outputs.aws-region }}"
          } catch {
            Write-Host "❌ Error retrieving secret: $($_.Exception.Message)"
            exit 1
          }

          if (-not $SECRET_SP) {
            Write-Host "❌ Failed to retrieve secret from AWS Secrets Manager"
            exit 1
          }

          Write-Host "Secret retrieved successfully"
          Write-Host ("Raw secret (first 50 chars): " + $SECRET_SP.Substring(0, [Math]::Min(50, $SECRET_SP.Length)) + "...")

          $ENVIRONMENT = "${{ inputs.environment || 'sandbox' }}"
          Write-Host "Target environment: $ENVIRONMENT"

          try {
            $secretObj = $SECRET_SP | ConvertFrom-Json
            Write-Host "Secret parsed successfully"
          } catch {
            Write-Host "❌ Failed to parse secret JSON: $($_.Exception.Message)"
            Write-Host "Raw secret content: $SECRET_SP"
            exit 1
          }

          # Extract fields
          $SERVICE_PRINCIPAL = $secretObj.service_principal_sandbox
          $CLIENT_SECRET     = $secretObj.client_secret
          $DATABRICKS_HOST   = if ($env:DATABRICKS_HOST_OVERRIDE) { $env:DATABRICKS_HOST_OVERRIDE } else { $secretObj.databricks_host_sandbox }

          Write-Host "=== Extracted Values ==="
          Write-Host "Service principal: $SERVICE_PRINCIPAL"
          Write-Host "Host: $DATABRICKS_HOST"
          Write-Host ("Client secret length: " + $CLIENT_SECRET.Length)

          if (-not $SERVICE_PRINCIPAL -or -not $CLIENT_SECRET -or -not $DATABRICKS_HOST) {
            Write-Host "❌ Missing required fields in secret"
            Write-Host ("Available keys in secret: " + ($secretObj.PSObject.Properties.Name -join ', '))
            exit 1
          }

          $configPath = Join-Path $home ".databrickscfg"
          $existingContent = if (Test-Path $configPath) { Get-Content $configPath -Raw } else { "" }

          # Prepare new profile content
          $profileName  = "${{ inputs.environment || 'sandbox' }}"
          $oauth        = "oauth-m2m"
          $newProfileLines = @(
            ""
            "[$profileName]"
            "host = $DATABRICKS_HOST"
            "auth_type = $oauth"
            "client_id = $SERVICE_PRINCIPAL"
            "client_secret = $CLIENT_SECRET"
          )
          $newProfileContent = ($newProfileLines -join [Environment]::NewLine)

          # Remove existing profile block, then append new one
          $pattern = "\[" + [regex]::Escape($profileName) + "\][\s\S]*?(?=\n\[|$)"
          $updatedContent = $existingContent -replace $pattern, ""
          $finalContent = $updatedContent.TrimEnd() + $newProfileContent

          Set-Content -LiteralPath $configPath -Value $finalContent -Encoding ASCII
          Write-Host "Databricks config written to: $configPath"

          # Set environment variable for bundle deployment
          "DATABRICKS_HOST=$DATABRICKS_HOST" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          $configContent = Get-Content $configPath -Raw
          if ($configContent -match ("\[" + [regex]::Escape($profileName) + "\]")) {
            Write-Host "✅ SUCCESS: '$profileName' profile created successfully"
          } else {
            Write-Host "❌ ERROR: '$profileName' profile NOT found in config file"
            Write-Host ("Config file size: " + (Get-Item $configPath).Length + " bytes")
            exit 1
          }

      - name: Verify Databricks Profile
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          $configPath = Join-Path $home ".databrickscfg"
          Write-Host "=== Verifying Databricks Profile ==="
          if (Test-Path $configPath) {
            Write-Host "Config file exists: $configPath"
            Get-Content $configPath
            if ((Get-Content $configPath -Raw) -match "\[sandbox\]") {
              Write-Host "✅ Sandbox profile found"
            } else {
              Write-Host "❌ Sandbox profile NOT found"
              exit 1
            }
          } else {
            Write-Host "❌ Config file does not exist at $configPath"
            exit 1
          }

      - name: Setup Databricks CLI
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          # Install the new Databricks CLI using pip
          pip install databricks-cli --upgrade

          # Verify installation
          try {
            databricks --version
            Write-Host "✅ Databricks CLI installed successfully"
          } catch {
            Write-Host "❌ Failed to verify Databricks CLI installation"
            exit 1
          }

      - name: Deploy bundles
        shell: powershell -NoProfile -ExecutionPolicy Bypass -Command "{0}"
        run: |
          $TARGET      = "${{ inputs.environment || 'sandbox' }}"
          $BUNDLE_NAME = "${{ inputs.bundle_name || '' }}"
          Write-Host "Deploying to target: $TARGET"

          if ($BUNDLE_NAME) {
            $bundlePath = Join-Path "bundles" $BUNDLE_NAME
            if (Test-Path (Join-Path $bundlePath "databricks.yml")) {
              Push-Location $bundlePath
              databricks bundle deploy --target $TARGET --profile $TARGET
              Pop-Location
            } else {
              Write-Host "❌ Bundle not found: $BUNDLE_NAME"
              exit 1
            }
          } else {
            Write-Host "Deploying all bundles"
            Get-ChildItem -Directory "bundles" | ForEach-Object {
              $cfg = Join-Path $_.FullName "databricks.yml"
              if (Test-Path $cfg) {
                Write-Host ("Deploying bundle: " + $_.Name + " to target: " + $TARGET)
                Push-Location $_.FullName
                databricks bundle deploy --target $TARGET --profile $TARGET
                Pop-Location
              }
            }
          }
